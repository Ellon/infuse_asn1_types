/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "JointLimitRange.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccOutOfBounds_Initialize(asn1SccOutOfBounds* pVal)
{
    *pVal = (asn1SccOutOfBounds) {
    .error_name = {0,
        {
        }
    },
    .min = 0.00000000000000000000E+000,
    .max = 0.00000000000000000000E+000,
    .value = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccOutOfBounds_IsConstraintValid(const asn1SccOutOfBounds* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->error_name, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->min, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->max, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->value, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccOutOfBounds_Encode(const asn1SccOutOfBounds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccOutOfBounds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode error_name */
	    ret = asn1SccT_String_Encode(&pVal->error_name, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode min */
	        ret = asn1SccT_Double_Encode(&pVal->min, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode max */
	            ret = asn1SccT_Double_Encode(&pVal->max, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode value */
	                ret = asn1SccT_Double_Encode(&pVal->value, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccOutOfBounds_Decode(asn1SccOutOfBounds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode error_name */
	ret = asn1SccT_String_Decode(&pVal->error_name, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode min */
	    ret = asn1SccT_Double_Decode(&pVal->min, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode max */
	        ret = asn1SccT_Double_Decode(&pVal->max, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode value */
	            ret = asn1SccT_Double_Decode(&pVal->value, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

flag asn1SccOutOfBounds_ACN_Encode(const asn1SccOutOfBounds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccOutOfBounds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode error_name */
	    ret = asn1SccT_String_ACN_Encode(&pVal->error_name, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode min */
	        ret = asn1SccT_Double_ACN_Encode(&pVal->min, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode max */
	            ret = asn1SccT_Double_ACN_Encode(&pVal->max, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode value */
	                ret = asn1SccT_Double_ACN_Encode(&pVal->value, pBitStrm, pErrCode, FALSE);

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccOutOfBounds_ACN_Decode(asn1SccOutOfBounds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode error_name */
    ret = asn1SccT_String_ACN_Decode(&pVal->error_name, pBitStrm, pErrCode);
    if (ret) {
        /*Decode min */
        ret = asn1SccT_Double_ACN_Decode(&pVal->min, pBitStrm, pErrCode);
        if (ret) {
            /*Decode max */
            ret = asn1SccT_Double_ACN_Decode(&pVal->max, pBitStrm, pErrCode);
            if (ret) {
                /*Decode value */
                ret = asn1SccT_Double_ACN_Decode(&pVal->value, pBitStrm, pErrCode);

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointLimitRange_Initialize(asn1SccJointLimitRange* pVal)
{
    *pVal = (asn1SccJointLimitRange) {
    .min = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    },
    .max = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccJointLimitRange_IsConstraintValid(const asn1SccJointLimitRange* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccJointState_IsConstraintValid(&pVal->min, pErrCode);
	if (ret) {
	    ret = asn1SccJointState_IsConstraintValid(&pVal->max, pErrCode);
	
	}

	return ret;
}

flag asn1SccJointLimitRange_Encode(const asn1SccJointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccJointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min */
	    ret = asn1SccJointState_Encode(&pVal->min, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max */
	        ret = asn1SccJointState_Encode(&pVal->max, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccJointLimitRange_Decode(asn1SccJointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min */
	ret = asn1SccJointState_Decode(&pVal->min, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode max */
	    ret = asn1SccJointState_Decode(&pVal->max, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccJointLimitRange_ACN_Encode(const asn1SccJointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccJointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min */
	    ret = asn1SccJointState_ACN_Encode(&pVal->min, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max */
	        ret = asn1SccJointState_ACN_Encode(&pVal->max, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccJointLimitRange_ACN_Decode(asn1SccJointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode min */
    ret = asn1SccJointState_ACN_Decode(&pVal->min, pBitStrm, pErrCode);
    if (ret) {
        /*Decode max */
        ret = asn1SccJointState_ACN_Decode(&pVal->max, pBitStrm, pErrCode);

    }


    return ret;
}

