/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Waypoint.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWaypoint_Initialize(asn1SccWaypoint* pVal)
{
    *pVal = (asn1SccWaypoint) {
    .position = {    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccWaypoint_IsConstraintValid(const asn1SccWaypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccWaypoint_Encode(const asn1SccWaypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWaypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccVector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = asn1SccT_Double_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = asn1SccT_Double_Encode(&pVal->tol_position, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = asn1SccT_Double_Encode(&pVal->tol_heading, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccWaypoint_Decode(asn1SccWaypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccVector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = asn1SccT_Double_Decode(&pVal->heading, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = asn1SccT_Double_Decode(&pVal->tol_position, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = asn1SccT_Double_Decode(&pVal->tol_heading, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

flag asn1SccWaypoint_ACN_Encode(const asn1SccWaypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccWaypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccVector3d_ACN_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = asn1SccT_Double_ACN_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = asn1SccT_Double_ACN_Encode(&pVal->tol_position, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = asn1SccT_Double_ACN_Encode(&pVal->tol_heading, pBitStrm, pErrCode, FALSE);

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccWaypoint_ACN_Decode(asn1SccWaypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode position */
    ret = asn1SccVector3d_ACN_Decode(&pVal->position, pBitStrm, pErrCode);
    if (ret) {
        /*Decode heading */
        ret = asn1SccT_Double_ACN_Decode(&pVal->heading, pBitStrm, pErrCode);
        if (ret) {
            /*Decode tol_position */
            ret = asn1SccT_Double_ACN_Decode(&pVal->tol_position, pBitStrm, pErrCode);
            if (ret) {
                /*Decode tol_heading */
                ret = asn1SccT_Double_ACN_Decode(&pVal->tol_heading, pBitStrm, pErrCode);

            }

        }

    }


    return ret;
}

