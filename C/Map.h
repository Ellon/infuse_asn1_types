#ifndef GENERATED_ASN1SCC_MAP_H
#define GENERATED_ASN1SCC_MAP_H
/*
Code automatically generated by asn1scc tool
*/
#include "taste-extended.h"
#include "TransformWithCovariance.h"
#include "taste-types.h"
#include "Time.h"
#include "Array3D.h"
#include "Frame.h"
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif



typedef struct {    int nCount; 
    
    asn1SccFrame_error_t arr[5];
} asn1SccMap_metadata_t_errValues;

#define asn1SccMap_metadata_t_errValues_REQUIRED_BYTES_FOR_ENCODING       67 
#define asn1SccMap_metadata_t_errValues_REQUIRED_BITS_FOR_ENCODING        533
#define asn1SccMap_metadata_t_errValues_REQUIRED_BYTES_FOR_ACN_ENCODING   67 
#define asn1SccMap_metadata_t_errValues_REQUIRED_BITS_FOR_ACN_ENCODING    533
#define asn1SccMap_metadata_t_errValues_REQUIRED_BYTES_FOR_XER_ENCODING   763

void asn1SccMap_metadata_t_errValues_Initialize(asn1SccMap_metadata_t_errValues* pVal);
flag asn1SccMap_metadata_t_errValues_IsConstraintValid(const asn1SccMap_metadata_t_errValues* val, int* pErrCode);
#ifndef ERR_asn1SccMap_metadata_t_errValues 
#define ERR_asn1SccMap_metadata_t_errValues		1001  /*(SIZE(0 .. mapMaxErrValues))*/
#endif

typedef enum {
    asn1Sccmap_UNDEF = 0,
    asn1Sccmap_DEM = 1,
    asn1Sccmap_NAV = 2
} asn1SccMap_type_t;

#define asn1SccMap_type_t_REQUIRED_BYTES_FOR_ENCODING       1 
#define asn1SccMap_type_t_REQUIRED_BITS_FOR_ENCODING        2
#define asn1SccMap_type_t_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define asn1SccMap_type_t_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define asn1SccMap_type_t_REQUIRED_BYTES_FOR_XER_ENCODING   46

void asn1SccMap_type_t_Initialize(asn1SccMap_type_t* pVal);
flag asn1SccMap_type_t_IsConstraintValid(const asn1SccMap_type_t* val, int* pErrCode);
#ifndef ERR_asn1SccMap_type_t_unknown_enumeration_value 
#define ERR_asn1SccMap_type_t_unknown_enumeration_value		1003  /**/
#endif
#ifndef ERR_asn1SccMap_type_t 
#define ERR_asn1SccMap_type_t		1002  /**/
#endif

typedef struct {
    asn1SccT_UInt32 msgVersion;
    asn1SccTime timeStamp;
    asn1SccMap_type_t type;
    asn1SccMap_metadata_t_errValues errValues;
    asn1SccT_Double scale;
    asn1SccTransformWithCovariance pose_fixedFrame_mapFrame;
} asn1SccMap_metadata_t;

#define asn1SccMap_metadata_t_REQUIRED_BYTES_FOR_ENCODING       1456 
#define asn1SccMap_metadata_t_REQUIRED_BITS_FOR_ENCODING        11641
#define asn1SccMap_metadata_t_REQUIRED_BYTES_FOR_ACN_ENCODING   1456 
#define asn1SccMap_metadata_t_REQUIRED_BITS_FOR_ACN_ENCODING    11641
#define asn1SccMap_metadata_t_REQUIRED_BYTES_FOR_XER_ENCODING   6453

void asn1SccMap_metadata_t_Initialize(asn1SccMap_metadata_t* pVal);
flag asn1SccMap_metadata_t_IsConstraintValid(const asn1SccMap_metadata_t* val, int* pErrCode);


typedef struct {
    asn1SccT_UInt32 msgVersion;
    asn1SccMap_metadata_t metadata;
    asn1SccArray3D data;
} asn1SccMap;

#define asn1SccMap_REQUIRED_BYTES_FOR_ENCODING       66357695 
#define asn1SccMap_REQUIRED_BITS_FOR_ENCODING        530861556
#define asn1SccMap_REQUIRED_BYTES_FOR_ACN_ENCODING   66356683 
#define asn1SccMap_REQUIRED_BITS_FOR_ACN_ENCODING    530853462
#define asn1SccMap_REQUIRED_BYTES_FOR_XER_ENCODING   132717148

void asn1SccMap_Initialize(asn1SccMap* pVal);
flag asn1SccMap_IsConstraintValid(const asn1SccMap* val, int* pErrCode);


extern const asn1SccT_UInt32 map_Version;
extern const asn1SccT_UInt32 mapMaxErrValues; 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

flag asn1SccMap_metadata_t_errValues_Encode(const asn1SccMap_metadata_t_errValues* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_metadata_t_errValues_Decode(asn1SccMap_metadata_t_errValues* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_metadata_t_errValues_ACN_Encode(const asn1SccMap_metadata_t_errValues* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_metadata_t_errValues_ACN_Decode(asn1SccMap_metadata_t_errValues* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_type_t_Encode(const asn1SccMap_type_t* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_type_t_Decode(asn1SccMap_type_t* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_type_t_ACN_Encode(const asn1SccMap_type_t* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_type_t_ACN_Decode(asn1SccMap_type_t* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_metadata_t_Encode(const asn1SccMap_metadata_t* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_metadata_t_Decode(asn1SccMap_metadata_t* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_metadata_t_ACN_Encode(const asn1SccMap_metadata_t* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_metadata_t_ACN_Decode(asn1SccMap_metadata_t* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_Encode(const asn1SccMap* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_Decode(asn1SccMap* pVal, BitStream* pBitStrm, int* pErrCode);
flag asn1SccMap_ACN_Encode(const asn1SccMap* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag asn1SccMap_ACN_Decode(asn1SccMap* pVal, BitStream* pBitStrm, int* pErrCode); 


#ifdef  __cplusplus
}
#define ENUM_asn1Sccmap_UNDEF	asn1Sccmap_UNDEF
#define ENUM_asn1Sccmap_DEM	asn1Sccmap_DEM
#define ENUM_asn1Sccmap_NAV	asn1Sccmap_NAV

#endif

#endif
