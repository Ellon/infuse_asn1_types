/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Time.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTime_Initialize(asn1SccTime* pVal)
{
    *pVal = (asn1SccTime) {
    .microseconds = -9223372036854775807LL,
    .usecPerSec = -2147483648LL
};
}
#endif

 
flag asn1SccTime_IsConstraintValid(const asn1SccTime* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int64_IsConstraintValid(&pVal->microseconds, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->usecPerSec, pErrCode);
	
	}

	return ret;
}

flag asn1SccTime_Encode(const asn1SccTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    ret = asn1SccT_Int64_Encode(&pVal->microseconds, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode usecPerSec */
	        ret = asn1SccT_Int32_Encode(&pVal->usecPerSec, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccTime_Decode(asn1SccTime* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode microseconds */
	ret = asn1SccT_Int64_Decode(&pVal->microseconds, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode usecPerSec */
	    ret = asn1SccT_Int32_Decode(&pVal->usecPerSec, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccTime_ACN_Encode(const asn1SccTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    ret = asn1SccT_Int64_ACN_Encode(&pVal->microseconds, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode usecPerSec */
	        ret = asn1SccT_Int32_ACN_Encode(&pVal->usecPerSec, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccTime_ACN_Decode(asn1SccTime* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode microseconds */
    ret = asn1SccT_Int64_ACN_Decode(&pVal->microseconds, pBitStrm, pErrCode);
    if (ret) {
        /*Decode usecPerSec */
        ret = asn1SccT_Int32_ACN_Decode(&pVal->usecPerSec, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccResolution_Initialize(asn1SccResolution* pVal)
{
    *pVal = (asn1SccResolution) asn1Sccseconds;
}
#endif

 
flag asn1SccResolution_IsConstraintValid(const asn1SccResolution* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccseconds) || (*pVal == asn1Sccmilliseconds)) || (*pVal == asn1Sccmicroseconds));
	*pErrCode = ret ? 0 : ERR_asn1SccResolution;

	return ret;
}

flag asn1SccResolution_Encode(const asn1SccResolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccResolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccmilliseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccmicroseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1078460417; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccResolution_Decode(asn1SccResolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 273154049;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccseconds;
	            break;
	        case 1: 
	            *pVal = asn1Sccmilliseconds;
	            break;
	        case 2: 
	            *pVal = asn1Sccmicroseconds;
	            break;
	        default:
		        *pErrCode = 1078460418;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccResolution_ACN_Encode(const asn1SccResolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccResolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccseconds:
	            intVal = 0;
	            break;
	        case asn1Sccmilliseconds:
	            intVal = 1;
	            break;
	        case asn1Sccmicroseconds:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1078460419;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	return ret;
}

flag asn1SccResolution_ACN_Decode(asn1SccResolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 2);
    *pErrCode = ret ? 0 : 273154050;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccseconds;
                break;
            case 1:
                *pVal = asn1Sccmilliseconds;
                break;
            case 2:
                *pVal = asn1Sccmicroseconds;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1078460420;      //COVERAGE_IGNORE
        };
    }
    return ret;
}

