/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Sequences.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFramesSequence_Initialize(asn1SccFramesSequence* pVal)
{
    *pVal = (asn1SccFramesSequence) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccFramesSequence_IsConstraintValid(const asn1SccFramesSequence* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= maxFramesSequenceLength);
	*pErrCode = ret ? 0 : ERR_asn1SccFramesSequence;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccFrame_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccFramesSequence_Encode(const asn1SccFramesSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccFramesSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccFrame_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccFramesSequence_Decode(asn1SccFramesSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
	*pErrCode = ret ? 0 : 280494081;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccFrame_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccFramesSequence_ACN_Encode(const asn1SccFramesSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccFramesSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccFrame_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccFramesSequence_ACN_Decode(asn1SccFramesSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
    *pErrCode = ret ? 0 : 280494082;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccFrame_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPosesSequence_Initialize(asn1SccPosesSequence* pVal)
{
    *pVal = (asn1SccPosesSequence) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccPosesSequence_IsConstraintValid(const asn1SccPosesSequence* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= maxPosesSequenceLength);
	*pErrCode = ret ? 0 : ERR_asn1SccPosesSequence;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccPose_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccPosesSequence_Encode(const asn1SccPosesSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPosesSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccPose_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccPosesSequence_Decode(asn1SccPosesSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
	*pErrCode = ret ? 0 : 280494083;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccPose_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccPosesSequence_ACN_Encode(const asn1SccPosesSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPosesSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccPose_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccPosesSequence_ACN_Decode(asn1SccPosesSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
    *pErrCode = ret ? 0 : 280494084;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccPose_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCorrespondenceMaps2DSequence_Initialize(asn1SccCorrespondenceMaps2DSequence* pVal)
{
    *pVal = (asn1SccCorrespondenceMaps2DSequence) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccCorrespondenceMaps2DSequence_IsConstraintValid(const asn1SccCorrespondenceMaps2DSequence* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= maxCorrespondenceMapsSequenceLength);
	*pErrCode = ret ? 0 : ERR_asn1SccCorrespondenceMaps2DSequence;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccCorrespondenceMap2D_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccCorrespondenceMaps2DSequence_Encode(const asn1SccCorrespondenceMaps2DSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccCorrespondenceMaps2DSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 56);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccCorrespondenceMap2D_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccCorrespondenceMaps2DSequence_Decode(asn1SccCorrespondenceMaps2DSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 56);
	*pErrCode = ret ? 0 : 280494085;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccCorrespondenceMap2D_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccCorrespondenceMaps2DSequence_ACN_Encode(const asn1SccCorrespondenceMaps2DSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccCorrespondenceMaps2DSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 56);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccCorrespondenceMap2D_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccCorrespondenceMaps2DSequence_ACN_Decode(asn1SccCorrespondenceMaps2DSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 56);
    *pErrCode = ret ? 0 : 280494086;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccCorrespondenceMap2D_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCorrespondenceMaps3DSequence_Initialize(asn1SccCorrespondenceMaps3DSequence* pVal)
{
    *pVal = (asn1SccCorrespondenceMaps3DSequence) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccCorrespondenceMaps3DSequence_IsConstraintValid(const asn1SccCorrespondenceMaps3DSequence* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= maxCorrespondenceMapsSequenceLength);
	*pErrCode = ret ? 0 : ERR_asn1SccCorrespondenceMaps3DSequence;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccCorrespondenceMap3D_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccCorrespondenceMaps3DSequence_Encode(const asn1SccCorrespondenceMaps3DSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccCorrespondenceMaps3DSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 56);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccCorrespondenceMap3D_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccCorrespondenceMaps3DSequence_Decode(asn1SccCorrespondenceMaps3DSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 56);
	*pErrCode = ret ? 0 : 280494087;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccCorrespondenceMap3D_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccCorrespondenceMaps3DSequence_ACN_Encode(const asn1SccCorrespondenceMaps3DSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccCorrespondenceMaps3DSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 56);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccCorrespondenceMap3D_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccCorrespondenceMaps3DSequence_ACN_Decode(asn1SccCorrespondenceMaps3DSequence* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 56);
    *pErrCode = ret ? 0 : 280494088;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccCorrespondenceMap3D_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}

const asn1SccT_UInt32 maxFramesSequenceLength = 10;

const asn1SccT_UInt32 maxPosesSequenceLength = 10;

const asn1SccT_UInt32 maxCorrespondenceMapsSequenceLength = 56;
