/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "DepthMap.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_horizontal_interval_Initialize(asn1SccDepthMap_horizontal_interval* pVal)
{
    *pVal = (asn1SccDepthMap_horizontal_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_horizontal_interval_IsConstraintValid(const asn1SccDepthMap_horizontal_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_horizontal_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccDepthMap_horizontal_interval_Encode(const asn1SccDepthMap_horizontal_interval* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccDepthMap_horizontal_interval_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_horizontal_interval_Decode(asn1SccDepthMap_horizontal_interval* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
	*pErrCode = ret ? 0 : 277872641;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccDepthMap_horizontal_interval_ACN_Encode(const asn1SccDepthMap_horizontal_interval* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccDepthMap_horizontal_interval_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_horizontal_interval_ACN_Decode(asn1SccDepthMap_horizontal_interval* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
    *pErrCode = ret ? 0 : 277872642;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccT_Double_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_vertical_interval_Initialize(asn1SccDepthMap_vertical_interval* pVal)
{
    *pVal = (asn1SccDepthMap_vertical_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_vertical_interval_IsConstraintValid(const asn1SccDepthMap_vertical_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_vertical_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccDepthMap_vertical_interval_Encode(const asn1SccDepthMap_vertical_interval* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccDepthMap_vertical_interval_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_vertical_interval_Decode(asn1SccDepthMap_vertical_interval* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
	*pErrCode = ret ? 0 : 277872643;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccDepthMap_vertical_interval_ACN_Encode(const asn1SccDepthMap_vertical_interval* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccDepthMap_vertical_interval_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_vertical_interval_ACN_Decode(asn1SccDepthMap_vertical_interval* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
    *pErrCode = ret ? 0 : 277872644;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccT_Double_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_remissions_Initialize(asn1SccDepthMap_remissions* pVal)
{
    *pVal = (asn1SccDepthMap_remissions) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_remissions_IsConstraintValid(const asn1SccDepthMap_remissions* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_remissions;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccDepthMap_remissions_Encode(const asn1SccDepthMap_remissions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccDepthMap_remissions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_remissions_Decode(asn1SccDepthMap_remissions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
	*pErrCode = ret ? 0 : 277872645;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccDepthMap_remissions_ACN_Encode(const asn1SccDepthMap_remissions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccDepthMap_remissions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_remissions_ACN_Decode(asn1SccDepthMap_remissions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
    *pErrCode = ret ? 0 : 277872646;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccT_Float_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_distances_Initialize(asn1SccDepthMap_distances* pVal)
{
    *pVal = (asn1SccDepthMap_distances) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_distances_IsConstraintValid(const asn1SccDepthMap_distances* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_distances;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccDepthMap_distances_Encode(const asn1SccDepthMap_distances* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccDepthMap_distances_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_distances_Decode(asn1SccDepthMap_distances* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
	*pErrCode = ret ? 0 : 277872647;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccDepthMap_distances_ACN_Encode(const asn1SccDepthMap_distances* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccDepthMap_distances_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_distances_ACN_Decode(asn1SccDepthMap_distances* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
    *pErrCode = ret ? 0 : 277872648;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccT_Float_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_timestamps_Initialize(asn1SccDepthMap_timestamps* pVal)
{
    *pVal = (asn1SccDepthMap_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        }        
    }
};
}
#endif

 
flag asn1SccDepthMap_timestamps_IsConstraintValid(const asn1SccDepthMap_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccDepthMap_timestamps_Encode(const asn1SccDepthMap_timestamps* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccDepthMap_timestamps_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccTime_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_timestamps_Decode(asn1SccDepthMap_timestamps* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
	*pErrCode = ret ? 0 : 277872649;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccTime_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccDepthMap_timestamps_ACN_Encode(const asn1SccDepthMap_timestamps* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccDepthMap_timestamps_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30000);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccTime_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccDepthMap_timestamps_ACN_Decode(asn1SccDepthMap_timestamps* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30000);
    *pErrCode = ret ? 0 : 277872650;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccTime_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccUNIT_AXIS_Initialize(asn1SccUNIT_AXIS* pVal)
{
    *pVal = (asn1SccUNIT_AXIS) asn1Sccunit_x;
}
#endif

 
flag asn1SccUNIT_AXIS_IsConstraintValid(const asn1SccUNIT_AXIS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccunit_x) || (*pVal == asn1Sccunit_y)) || (*pVal == asn1Sccunit_z));
	*pErrCode = ret ? 0 : ERR_asn1SccUNIT_AXIS;

	return ret;
}

flag asn1SccUNIT_AXIS_Encode(const asn1SccUNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccUNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccunit_x:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccunit_y:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccunit_z:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1083179009; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccUNIT_AXIS_Decode(asn1SccUNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 277872651;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccunit_x;
	            break;
	        case 1: 
	            *pVal = asn1Sccunit_y;
	            break;
	        case 2: 
	            *pVal = asn1Sccunit_z;
	            break;
	        default:
		        *pErrCode = 1083179010;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccUNIT_AXIS_ACN_Encode(const asn1SccUNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccUNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccunit_x:
	            intVal = 0;
	            break;
	        case asn1Sccunit_y:
	            intVal = 1;
	            break;
	        case asn1Sccunit_z:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1083179011;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	return ret;
}

flag asn1SccUNIT_AXIS_ACN_Decode(asn1SccUNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 2);
    *pErrCode = ret ? 0 : 277872652;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccunit_x;
                break;
            case 1:
                *pVal = asn1Sccunit_y;
                break;
            case 2:
                *pVal = asn1Sccunit_z;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1083179012;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDEPTH_MEASUREMENT_STATE_Initialize(asn1SccDEPTH_MEASUREMENT_STATE* pVal)
{
    *pVal = (asn1SccDEPTH_MEASUREMENT_STATE) asn1Sccvalid_measurement;
}
#endif

 
flag asn1SccDEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccDEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1Sccvalid_measurement) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_too_far)) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_too_near)) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_measurement_error));
	*pErrCode = ret ? 0 : ERR_asn1SccDEPTH_MEASUREMENT_STATE;

	return ret;
}

flag asn1SccDEPTH_MEASUREMENT_STATE_Encode(const asn1SccDEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccDEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccvalid_measurement:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case asn1SccDEPTH_MEASUREMENT_STATE_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case asn1SccDEPTH_MEASUREMENT_STATE_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case asn1SccDEPTH_MEASUREMENT_STATE_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = 1083179013; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccDEPTH_MEASUREMENT_STATE_Decode(asn1SccDEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	*pErrCode = ret ? 0 : 277872653;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccvalid_measurement;
	            break;
	        case 1: 
	            *pVal = asn1SccDEPTH_MEASUREMENT_STATE_too_far;
	            break;
	        case 2: 
	            *pVal = asn1SccDEPTH_MEASUREMENT_STATE_too_near;
	            break;
	        case 3: 
	            *pVal = asn1SccDEPTH_MEASUREMENT_STATE_measurement_error;
	            break;
	        default:
		        *pErrCode = 1083179014;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccDEPTH_MEASUREMENT_STATE_ACN_Encode(const asn1SccDEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccDEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccvalid_measurement:
	            intVal = 0;
	            break;
	        case asn1SccDEPTH_MEASUREMENT_STATE_too_far:
	            intVal = 1;
	            break;
	        case asn1SccDEPTH_MEASUREMENT_STATE_too_near:
	            intVal = 2;
	            break;
	        case asn1SccDEPTH_MEASUREMENT_STATE_measurement_error:
	            intVal = 3;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1083179015;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 3);
    }

	return ret;
}

flag asn1SccDEPTH_MEASUREMENT_STATE_ACN_Decode(asn1SccDEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 3);
    *pErrCode = ret ? 0 : 277872654;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccvalid_measurement;
                break;
            case 1:
                *pVal = asn1SccDEPTH_MEASUREMENT_STATE_too_far;
                break;
            case 2:
                *pVal = asn1SccDEPTH_MEASUREMENT_STATE_too_near;
                break;
            case 3:
                *pVal = asn1SccDEPTH_MEASUREMENT_STATE_measurement_error;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1083179016;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPROJECTION_TYPE_Initialize(asn1SccPROJECTION_TYPE* pVal)
{
    *pVal = (asn1SccPROJECTION_TYPE) asn1Sccpolar;
}
#endif

 
flag asn1SccPROJECTION_TYPE_IsConstraintValid(const asn1SccPROJECTION_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccpolar) || (*pVal == asn1Sccplanar));
	*pErrCode = ret ? 0 : ERR_asn1SccPROJECTION_TYPE;

	return ret;
}

flag asn1SccPROJECTION_TYPE_Encode(const asn1SccPROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccpolar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccplanar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1083179017; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPROJECTION_TYPE_Decode(asn1SccPROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 277872655;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccpolar;
	            break;
	        case 1: 
	            *pVal = asn1Sccplanar;
	            break;
	        default:
		        *pErrCode = 1083179018;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPROJECTION_TYPE_ACN_Encode(const asn1SccPROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccPROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccpolar:
	            intVal = 0;
	            break;
	        case asn1Sccplanar:
	            intVal = 1;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1083179019;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
    }

	return ret;
}

flag asn1SccPROJECTION_TYPE_ACN_Decode(asn1SccPROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 1);
    *pErrCode = ret ? 0 : 277872656;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccpolar;
                break;
            case 1:
                *pVal = asn1Sccplanar;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1083179020;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_Initialize(asn1SccDepthMap* pVal)
{
    *pVal = (asn1SccDepthMap) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            }        
        }
    },
    .vertical_projection = asn1Sccpolar,
    .horizontal_projection = asn1Sccpolar,
    .vertical_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .horizontal_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertical_size = 0,
    .horizontal_size = 0,
    .distances = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .remissions = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccDepthMap_IsConstraintValid(const asn1SccDepthMap* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccDepthMap_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccPROJECTION_TYPE_IsConstraintValid(&pVal->vertical_projection, pErrCode);
	        if (ret) {
	            ret = asn1SccPROJECTION_TYPE_IsConstraintValid(&pVal->horizontal_projection, pErrCode);
	            if (ret) {
	                ret = asn1SccDepthMap_vertical_interval_IsConstraintValid(&pVal->vertical_interval, pErrCode);
	                if (ret) {
	                    ret = asn1SccDepthMap_horizontal_interval_IsConstraintValid(&pVal->horizontal_interval, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->vertical_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->horizontal_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccDepthMap_distances_IsConstraintValid(&pVal->distances, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccDepthMap_remissions_IsConstraintValid(&pVal->remissions, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccDepthMap_Encode(const asn1SccDepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccDepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode ref_time */
	    ret = asn1SccTime_Encode(&pVal->ref_time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        ret = asn1SccDepthMap_timestamps_Encode(&pVal->timestamps, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode vertical_projection */
	            ret = asn1SccPROJECTION_TYPE_Encode(&pVal->vertical_projection, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode horizontal_projection */
	                ret = asn1SccPROJECTION_TYPE_Encode(&pVal->horizontal_projection, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode vertical_interval */
	                    ret = asn1SccDepthMap_vertical_interval_Encode(&pVal->vertical_interval, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode horizontal_interval */
	                        ret = asn1SccDepthMap_horizontal_interval_Encode(&pVal->horizontal_interval, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode vertical_size */
	                            ret = asn1SccT_UInt32_Encode(&pVal->vertical_size, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode horizontal_size */
	                                ret = asn1SccT_UInt32_Encode(&pVal->horizontal_size, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode distances */
	                                    ret = asn1SccDepthMap_distances_Encode(&pVal->distances, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode remissions */
	                                        ret = asn1SccDepthMap_remissions_Encode(&pVal->remissions, pBitStrm, pErrCode, FALSE);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccDepthMap_Decode(asn1SccDepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode ref_time */
	ret = asn1SccTime_Decode(&pVal->ref_time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = asn1SccDepthMap_timestamps_Decode(&pVal->timestamps, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode vertical_projection */
	        ret = asn1SccPROJECTION_TYPE_Decode(&pVal->vertical_projection, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode horizontal_projection */
	            ret = asn1SccPROJECTION_TYPE_Decode(&pVal->horizontal_projection, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode vertical_interval */
	                ret = asn1SccDepthMap_vertical_interval_Decode(&pVal->vertical_interval, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode horizontal_interval */
	                    ret = asn1SccDepthMap_horizontal_interval_Decode(&pVal->horizontal_interval, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode vertical_size */
	                        ret = asn1SccT_UInt32_Decode(&pVal->vertical_size, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode horizontal_size */
	                            ret = asn1SccT_UInt32_Decode(&pVal->horizontal_size, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode distances */
	                                ret = asn1SccDepthMap_distances_Decode(&pVal->distances, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode remissions */
	                                    ret = asn1SccDepthMap_remissions_Decode(&pVal->remissions, pBitStrm, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag asn1SccDepthMap_ACN_Encode(const asn1SccDepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccDepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode ref_time */
	    ret = asn1SccTime_ACN_Encode(&pVal->ref_time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        ret = asn1SccDepthMap_timestamps_ACN_Encode(&pVal->timestamps, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode vertical_projection */
	            ret = asn1SccPROJECTION_TYPE_ACN_Encode(&pVal->vertical_projection, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode horizontal_projection */
	                ret = asn1SccPROJECTION_TYPE_ACN_Encode(&pVal->horizontal_projection, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode vertical_interval */
	                    ret = asn1SccDepthMap_vertical_interval_ACN_Encode(&pVal->vertical_interval, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode horizontal_interval */
	                        ret = asn1SccDepthMap_horizontal_interval_ACN_Encode(&pVal->horizontal_interval, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode vertical_size */
	                            ret = asn1SccT_UInt32_ACN_Encode(&pVal->vertical_size, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode horizontal_size */
	                                ret = asn1SccT_UInt32_ACN_Encode(&pVal->horizontal_size, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode distances */
	                                    ret = asn1SccDepthMap_distances_ACN_Encode(&pVal->distances, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode remissions */
	                                        ret = asn1SccDepthMap_remissions_ACN_Encode(&pVal->remissions, pBitStrm, pErrCode, FALSE);

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccDepthMap_ACN_Decode(asn1SccDepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode ref_time */
    ret = asn1SccTime_ACN_Decode(&pVal->ref_time, pBitStrm, pErrCode);
    if (ret) {
        /*Decode timestamps */
        ret = asn1SccDepthMap_timestamps_ACN_Decode(&pVal->timestamps, pBitStrm, pErrCode);
        if (ret) {
            /*Decode vertical_projection */
            ret = asn1SccPROJECTION_TYPE_ACN_Decode(&pVal->vertical_projection, pBitStrm, pErrCode);
            if (ret) {
                /*Decode horizontal_projection */
                ret = asn1SccPROJECTION_TYPE_ACN_Decode(&pVal->horizontal_projection, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode vertical_interval */
                    ret = asn1SccDepthMap_vertical_interval_ACN_Decode(&pVal->vertical_interval, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode horizontal_interval */
                        ret = asn1SccDepthMap_horizontal_interval_ACN_Decode(&pVal->horizontal_interval, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode vertical_size */
                            ret = asn1SccT_UInt32_ACN_Decode(&pVal->vertical_size, pBitStrm, pErrCode);
                            if (ret) {
                                /*Decode horizontal_size */
                                ret = asn1SccT_UInt32_ACN_Decode(&pVal->horizontal_size, pBitStrm, pErrCode);
                                if (ret) {
                                    /*Decode distances */
                                    ret = asn1SccDepthMap_distances_ACN_Decode(&pVal->distances, pBitStrm, pErrCode);
                                    if (ret) {
                                        /*Decode remissions */
                                        ret = asn1SccDepthMap_remissions_ACN_Decode(&pVal->remissions, pBitStrm, pErrCode);

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }


    return ret;
}

const asn1SccT_UInt32 maxDepthMapSize = 30000;
